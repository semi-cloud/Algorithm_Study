# 분할 정복 알고리즘

## Divide and Conquer?

### 분할 정복 정의
+ 엄청나고 큰 방대한 문제를 나눈 후 다시 합쳐서 해결하는 알고리즘
  + 1.Divde(분할) : 해결할 문제를 여러 개의 작은 부분 문제들로 분할
  + 2.Conquer(정복) : 작은 문제를 순환적으로 분할 후 가장 작은 단위의 하위 문제를 해결하여 정복
  + 3.Combine(통합) : 작은 문제의 정복된 해를 결합해 최종 해를 구함
+ 분할된 작은 문제는 (1)원문제와 성격이 **동일**하며(입력 크기만 작아짐), (2)서로 **독립적**임(순환적 분할 및 결과 결합 가능)

> :pencil2: Recursive(순환적), Top-down 방식 알고리즘
 + `Top-down 방식` : 최상위 사례의 해답은, 아래로 내려가면서 작은 사례에 대한 해답을 구함으로써 해결!

<img src = "https://user-images.githubusercontent.com/71436576/126745011-b21956f0-ee46-4767-aaec-9d2497977b75.png" width=50% height=50%>

> 예시 => 거듭제곱
  + 짝수 일때 : C^8 = C^4 * C^4 = (C^4)^2 = ((C^2)^2)^2
  + 홀수 일때 : C^15 = C^7 * C^7 * C^1 , C^7 = C^3 * C^3 * C^1, C^3 = C^1 * C^1 * C^1

 ```java
 public int Recursive(C,n){
    if(n==1) return C;
    if(n % 2 == 0 ) {     //even
      y = Recursive(C, n/2)
      return y * y;
    }else{                //odd
      y = Recursive(C, (n-1)/2);
      return y*y*C;
    } 
 }
 ```
  + 분할 정복 사용하지 않았을때의 O(N) => 사용 후 O(log2n)으로 시간 복잡도가 줄어들었다!
### 분할 정복 장단점
+ 장점 : 병렬적으로 문제를 해결하는데 큰 강점 존재
+ 단점 : 함수의 재귀적 호출로 인한 오버헤드가 발생, 스택 오버플로우 발생, 과도한 메모리 사용

## 분할 정복 활용

### 이분 검색

### 병합 정렬

### 퀵 정렬

### 최댓값 찾기
