### #1699
 + 주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수 구하기
  + ex) 11=3^2+1^2+1^2(3개 항) 11=2^2+2^2+1^2+1^2+1^2(5개 항)
 
 > 풀이 방법
  + :pencil2: _현재의 제곱수의 최소값을 위해, **이전 수의 최소값을 이용**하여서 최소값을 만들어야함_ 
    + `Botton-UP을 이용한 DP(Memoization)`
  + `1 ~ N 까지의 수 중 제곱수인 수` + `(N-제곱수)의 최소 제곱수 갯수 중 최소인 값`
    + EX) 7 => (7-1^2) 의 값과 (7-2^2)의 최소 제곱수의 합 중 가장 작은 값 + 1
  + **DP[i] = DP[i - (j * j)] + 1**
    + DP[i] = 제곱수 합의 최소 개수
 
### #1890
 + 현재 칸에서 오른쪽, 아래쪽으로 종착점 까지 이동가능한 경로 개수 구하기
   + 칸에 적혀있는 수만큼 거리 이동
 
 > 1차 풀이 방법: 재귀 호출로 인한 시간초과
 ```java
 static int[] dx = {1, 0}, dy = {0, 1}; //아래, 우
 
 public static void game(int x, int y) {
    if(arr[x][y] == 0) {  //종착점에 도달하면
        cnt++;
        return;
    }

    for(int i = 0; i < 2 ; i++) {  //선택지 2개
        int nx = x + dx[i] * arr[x][y];   //x,y 칸 이동
        int ny = y + dy[i] * arr[x][y]; 

        if(nx < 0 || ny < 0 || nx >= N || ny >= N ) {continue;}  //범위 벗어나면 이동 X	
        game(nx, ny);			 
    }
 }
 ```
> 2차 풀이 방법: **DP** 이용(140ms)

#### ❓ 문제를 풀면서, 중복되어 불필요한 계산을 반복해서 한 부분이 있었는가
+ `초기`: 이동 거리를 계산하는 부분이 반복해서, 이동거리를 dp배열에 저장해야한다고 생각
+ `Solution` : **dp[i][j] = 현재 칸까지 올 수 있는 경우의 수**(이동거리 X)
  + `dp[][]`배열과, `arr[][]`배열을 나누어 dp배열의 원소는 이동가능한 경우의 수 저장

#### ✔️주의해야 할 점(문제 조건 CHECK)
+ `경우의 수 <= 2^63-1`: Long(16byte = 64bits) 자료형 사용
+ `N <= 100`: `O(n^2)`을 고려하여 완전탐색을 이용해 dp배열을 채워도 시간 초과 X
