# BackTracking

## 백트래킹이란?
 + 해를 찾는 도중 해가 아니어서 막히면, **되돌아가서 다시 해를 찾아가는 기법**
 + 1)최적화(Optimization) 문제와 2)결정(Decision) 문제를 푸는 방법
   + `결정 문제` : 문제의 조건을 만족 해가 존재하는지 여부를 'Yes', 'No'로 답하는 문제
   
> DFS vs BackTracking

### :heavy_check_mark: DFS
 + 가능한 모든 경로(후보)를 탐색
 + 불필요할 것 같은 경로를 사전에 차단하거나 하는 등의 행동이 X => 경우의 수를 줄이지 못함 
   + `N!` 가지의 경우의 수를 가진 문제는 DFS로 처리가 불가능! 
 + 해가 될 가능성이 없는 노드의 후손노드들도 모두 검색해 비효율적
 
### :heavy_check_mark: BackTracking
 + 어떤 노드에서 출발하는 경로가 해결책이 될 가능성이 낮으면, 더이상 따라가지 않음(가지치기)
   + 가지치기를 얼마나 잘하느냐에 따라 효율성이 결정
 + 필요한 경로를 조기에 차단할 수 있게 되어, 경우의 수가 줄어들음

### 백트래킹 알고리즘 절차
 1) 상태 공간 트리에 대한 DFS(깊이 우선 탐색) 실시</br>
 2) 방문하는 노드가 유망한지 여부 점검</br>
 4) 만일 선택 노드가 유망하지 X, 해당 노드의 부모 노드로 돌아가 검색 계속 진행

# BackTracking 활용

## 부분 집합
 + `Power Set` : 어떤 집합의 공집합 + 자기 자신을 포함한 **모든 부분집합**
 + 구하고자 하는 집합 원소의 개수가 N개일때, **부분집합 개수는 2^N**
 + 일반적으로 BackTracking 접근 방법 이용!

> 방법 1(부분 집합의 합 구하기)
```java
if(k == n) {
			for(int i = 0; i < n ;i++) {
				if(a[i] == 1) { 
            sum += arr[i];       //같은 경로 모든 노드의 합
        }	   
			}
			if(sum == S) {cnt++;}			
		}else {
			a[k] = 0;       //가지가 0, 1 두개로 나뉨
			recur(a, k + 1, n);
			a[k] = 1;
			recur(a, k + 1, n);			
		}
```
  + 1또는 0 값을 가지는 항목들로 구성된 n개의 list를 이용(이진 트리 형태)
    + list[i] = i번째 원소가 부분집합에 포함되는지 여부를 표현(1 : 포함, 0 : 포함X)

> 방법 2(부분 집합의 합 구하기)

```java
Arrays.sort(arr);    //오름 차순으로 정렬

private static void recur(int v, int su) {
		if(v == N) {
			if(su == S) cnt++;
			return;
		}

		recur(v + 1, su + arr[v]);  //지금 원소를 합에 더하는 부분
		recur(v + 1, su);      지금 위치의 원소는 빼고 구하는 부분
}

System.out.print(S == 0? --cnt : cnt);
```
 + 각 방문시 `1)이번 원소 포함` , `2)이번 원소 포함 X` 두개의 선택지를 탐색
 
